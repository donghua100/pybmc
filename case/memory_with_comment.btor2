; BTOR description generated by Yosys 0.14 (git sha1 UNKNOWN, clang 13.0.0 -fPIC -Os) for module TOP.
1 sort bitvec 1
2 input 1 clk         ; 时钟信号
3 input 1 flag_fail   ; 
4 input 1 in_data     ; 输入数据
5 input 1 in_rd       ; 读信号
6 input 1 in_rd_addr  ; 读单元的地址
7 input 1 in_wr       ; 写信号
8 input 1 in_wr_addr  ; 写单元的地址
9 input 1 rst_n       ; 复位信号

10 state 1            ; sid_1 代表的是1位的bitvec类型
11 output 10 out_data ; 将 nid_10(上一行声明的1位bv类型的state)作为输出，记为out_data
12 state 1            ; id_59使用next
13 const 1 0          ; 1 是sid，0是按位赋值，得到的nid 13是一个输入常数

14 state 1
15 init 1 14 13       ; 1 是sid，14、13是nid，用0初始化id_14

16 not 1 12           ; 对于运算表达式，btor2的格式为 nid op sid nid[nid[nid]]，分别为结果的identifier、操作符、结果的类型、1~3个操作数
17 and 1 14 16        ; ... (flag && rst_n) && !12

; assume property((in_wr && in_rd) == 0);
18 and 1 7 5          ; in_wr && in_rd  
19 sort bitvec 31
20 const 19 0000000000000000000000000000000
21 sort bitvec 32
22 concat 21 20 18    ; 将id_20(31位bv)和id_18(1位bv)合并，得到id_22(32位bv)
23 redor 1 22         ; reduction or，类似Verilog中的递减运算符。如“redor C”表示将C的第一位与第二位相或，再将结果与第三位相或，…一直到最后一位。原因?
24 not 1 23           ; !(in_wr && in_rd)
25 const 1 1          ; const 1
26 not 1 25           ; const 0
27 or 1 24 26
28 constraint 27      ; !(in_wr && in_rd) || 0，即 memory.sv中定义的性质 (in_wr && in_rd) == 0，定义为 constraint

; initial assume(flag == 1'b0);
29 state 1 flag
30 not 1 29           ; !flag
31 state 1
32 init 1 31 25       ; init id_31(state) with const 1
33 next 1 31 13       ; 在下一时刻，将常数id_13(1'b0)赋值给状态结点id_31，1是sid，用于区分目标是寄存器还是存储器
34 not 1 31           ; id_31每次被赋值为0，not id_31 得到的是1
35 or 1 30 34 
36 constraint 35      ; !flag || 1， 即 flag == 1'b0

; initial assume(flag_fail == 1'b0);
37 not 1 3            ; !flag_fail
38 not 1 31
39 or 1 37 38      
40 constraint 39      ; !flag_fail || 1， 即 flag_fail == 1'b0

; initial ~rst_n == 1'b1
41 not 1 9
42 not 1 31
43 or 1 41 42
44 constraint 43      ; !rst_n，即 ~rst_n == 1'b1

45 state 1
46 next 1 45 45
47 uext 1 45 0 random_addr ; uext ...
48 state 1 random_data ; 声明了random_addr、random_data


; mem 的声明
49 sort array 1 1     ; array 1(单元的位宽) 1(单元的数量)
50 state 49 mem       ; 声明新的类型 mem

; mem 的读操作
51 read 1 50 6        ; mem[in_rd_addr]
52 ite 1 5 51 10      ; 如果id_5为1(in_rd = 1)，则选择id_51(read)，否则选择id_10(out_data)
53 ite 1 9 52 13      ; 如果id_9为1(rst_n)，则选择id_52，否则选择id_13(const 0)，通过嵌套实现了if的多分支，而条件顺序倒过来实现
54 next 1 10 53       ; 下一时刻将结果(id_53)同步到id_10(out_data)

55 input 1
56 eq 1 48 10         ; random_data == out_data
57 and 1 29 9         ; flag && rst_n
58 ite 1 57 56 55     ; 如果id_57(flag && rst_n)满足，选择id_56(random_data == out_data)，否则选择id_55(input 1)
59 next 1 12 58       ; ...

; 
60 ite 1 57 25 13     ; 如果id_57(flag && rst_n)满足，选择id_25(const 1)，否则选择id_13(const 0)
61 next 1 14 60       ; flag && rst_n

; ast1_pass中的第一个if语句：flag <= ( (rst_n && in_rd) && (in_rd_addr == random_addr) ? 1 : 0 )
62 and 1 9 5          ; rst_n && in_rd
63 eq 1 6 45          ; in_rd_addr == random_addr
64 and 1 62 63        ; (rst_n && in_rd) && (in_rd_addr == random_addr)
65 ite 1 64 25 13     ; (rst_n && in_rd) && (in_rd_addr == random_addr) ? 1 : 0
66 next 1 29 65       ; 将id_65的结果放到id_29(flag)

; random_data 赋值语句块
67 eq 1 8 45          ; in_wr_addr == random_addr
68 and 1 7 67         ; in_wr && (in_wr_addr == random_addr)
69 ite 1 68 4 48      ; in_wr && (in_wr_addr == random_addr) ? in_data : random_data
70 ult 1 45 25        ; random_addr < const 1，ult(unsign little than)
71 and 1 68 70        ; in_wr && (in_wr_addr == random_addr) && (random_addr < const 1) ...
72 ite 1 71 4 69      ; id_71 ? in_data : id_69
73 ite 1 9 72 13      ; rst_n ? id_72 : 0
74 next 1 48 73       ; 将id_65的结果放到id_48(random_data)

; mem 的写操作
75 ite 1 9 13 25      ; rst_n ? 0 : 1
76 read 1 50 13       ; mem[0]
77 not 1 75           ; rst_n
78 and 1 76 77        ; mem[0] && rst_n
79 and 1 13 75        ; 0 && !rst_n 
80 or 1 79 78         ; mem[0] && rst_n
81 write 49 50 13 80  ; mem[0] = mem[0] && rst_n
82 redor 1 75         ; !rst_n
83 ite 49 82 81 50    ; !rst_n ? mem[0] = mem[0] && rst_n : mem

84 read 1 83 25       ; 可能修改后的mem的mem[1]
85 not 1 75
86 and 1 84 85        ; rst_n && mem[1]
87 and 1 13 75
88 or 1 87 86
89 write 49 83 25 88
90 redor 1 75
91 ite 49 90 89 83    ; !rst_n ? mem[1] = mem[1] && rst_n : mem

92 input 1
93 input 1
94 input 1
95 ult 1 8 25         ; in_wr_addr < 1
96 ite 1 95 4 94      ; in_wr_addr < 1 ? in_data : input 1
97 ite 1 7 96 93      ; in_wr ? id_96 : input 1 ...
98 ite 1 9 97 92      ; rst_n ? id_97 : input 1

99 input 1
100 input 1
101 input 1
102 ite 1 95 101 4    ; in_wr_addr < 1 ? input 1 : in_data
103 ite 1 7 102 100   ; in_wr ? id_102 : input 1
104 ite 1 9 103 99    ; rst_n ? id_97 : input 1
105 ite 1 95 13 25    ; in_wr_addr < 1 ? 0 : 1
106 ite 1 7 105 13    ; in_wr ? id_105 : 0
107 ite 1 9 106 13    ; rst_n ? id_106 : 0
108 ite 1 107 104 98  ; id_107 ? id_104 : id_98，继续嵌套条件

109 ite 1 95 25 13    ; in_wr_addr < 1 ? 1 : 0
110 ite 1 7 109 13    ; in_wr ? id_109 : 0
111 ite 1 9 110 13    ; rst_n ? id_110 : 0
112 or 1 111 107      ; 
113 read 1 91 8       ; 修改后的mem，mem[in_wr_addr]
114 not 1 112
115 and 1 113 114
116 and 1 108 112
117 or 1 116 115      ; 嵌套结构实现了in_data的分割 ...
118 write 49 91 8 117  ; 结果为array类型，mem[in_wr_addr] = in_data
119 redor 1 112
120 ite 49 119 118 91  ; 条件id_119成立，则选择id_118(写操作之后的mem)；否则选择id_91(写操作之前的mem)
121 next 49 50 120 mem ; sid_49是存储器(bv数组)类型，将id_120作为状态id_50(mem)的下一时刻的输入

122 bad 17
; end of yosys output

((((rst_n = 1_1) ? ((... = ...) ? (... ? ... : ...) : 0_1) : 0_1) | ((rst_n = 1_1) ? ((... = ...) ? (... ? ... : ...) : 0_1) : 0_1)) ROR 1)